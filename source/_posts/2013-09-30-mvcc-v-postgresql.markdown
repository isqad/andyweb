---
layout: post
title: "MVCC в Postgresql"
date: 2013-09-30 14:30
comments: true
categories:
---
Внутри Postgresql целостность данных поддерживается благодаря модели мультиверсионности (MVCC).
Это означает, что при запросе каждая транзакция "видит" снимок данных, каким он был некоторое время назад,
независимо от текущего состояния данных. Защита транзации от просмотра нецелостных данных, которые
могут появиться в результате параллельных изменений одних и тех же данных, обеспечивается изоляцией
транзации для каждой сессии. MVCC позволяет избежать методик "грубых" блокировок данных (как это сделано в
традиционных БД), и исходя из этого, позволяет достичь приемлемой производительности в многопользовательской среде.

Приемущество MVCC в том, что чтение никогда не блокирует запись, а запись никогда не блокирует чтение. Чтобы иметь
такую возможность, данные из таблицы не удаляются сразу, а помечаются как удаленные. Изменение записей
осуществляется путем пометки их как удаленные, и созданием новых записей с измененными полями. Что в результате может
происходить читайте по [ссылке](http://andyweb.ru/blog/2013/09/30/table-bloat/).

История изменения записей доступна для чтения другим транзакциям. У каждой записи есть скрытые системные поля:

* xmin - номер (id) транзакции, в которой запись была создана
* xmax - номер транзакции, в которой запись была удалена или изменена

В упрощеном (очень) виде работу MVCC можно представить так:

``` sql
-- Допустим, есть запрос:
SELECT * FROM table WHERE x = 25;

-- Postgresql добавляет дополнительные условия в ходе анализа запроса
SELECT * FROM table WHERE x = 25 AND is_tuple_visible(xmin, xmax, snapshot);

```

, где is_tuple_visible - функция, которая по xmin, xmax и сохраненного снимка snapshot определяет, видна
ли запись или нет.

